'''
백준 1300
'''
'''
A = [
    [1, 2, 3],
    [2, 4, 6],
    [3, 6, 9]
]

B = [1, 2, 2, 3, 3, 4, 6, 6, 9]
k = 7
B[7] = 6

이 문제는 이분탐색으로 풀 수 있는 문제이다.
사실 처음에는 for 문으로 풀었는데, 하나하나씩 만들어서 오름차순 정렬시키기 때문에 매우 비효율적이다.

우리는 이분탐색으로 어떤 수보다 작은 자연수의 곱(i*j)이 몇 개인지 알아낼 것이다.
A보다 작은 숫자가 몇개인지 찾아내면 A가 몇 번째 숫자인지 알 수 있다.

예를 들어 10 * 10 에서 20보다 작거나 같은 수를 생각해보자
1*1 ~ 1*10
2*1 ~ 2*2
3*1 ~ 3*6
.
.
.
10*1 ~ 10*2
위 수가 존재할텐데, 이는 반대로 생각해보면 20을 행으로 나눈 몫이다.
20//1 : 10개 단 열의 숫자 (n * n 배열이므로)를 초과할 수 없다.
20//2 : 10개
20//3 : 6개
.
,
,
20//10 : 2개
따라서 이를 식으로 표기해보면 아래와 같다.
temp = 0
for i in range(1, n + 1):
    temp += min(mid//i, n)

이렇게 해당 숫자(mid)보다 작거나 같은 숫자들을 전부 찾아줌으로써 mid가 몇번째에 위치한 숫자인지 알아낼 수 있다.

찾고자 하는 값을 mid라고 정해서 이 값보다 작거나 같은 값을 행마다 찾는다.
이분탐색 너무 전형적인 문제에 익숙해서 약간만 변형해도 파악을 못하는 데 아쉬웠다.

ex)
n = 3, k = 7

start, end = 1, 7

while start <= end:
    mid = 4

    temp = 0
    for i in range(1, 4):
        i == 1 일때,
        temp += min(4, 3) = 3

        i == 2 일때,
        temp += min(2, 3) = 5

        i == 3 일때,
        temp += min(1, 3) = 1
'''

n = int(input())
k = int(input())

start, end = 1, k

while start <= end:
    mid = (start + end) // 2

    temp = 0
    for i in range(1, n + 1):
        temp += min(mid//i, n) # mid 이하의 i의 배수 or 최대 n

    if temp >= k: # 이분탐색 실행
        answer = mid
        end = mid - 1
    else:
        start = mid + 1

print(answer)
