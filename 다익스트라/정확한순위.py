inf = int(1e9)

# 노드와 간선 정보 받기
n, m = map(int, input().split())
# inf를 초기값으로 한 2차원 배열 선언
graph = [[inf] * (n + 1) for _ in range(n + 1)]

# 자기 자신으로 가는 건 0으로 초기화
for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

# 간선 정보 입력 받기
for i in range(m):
    a, b = map(int, input().split())
    graph[a][b] = 1

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n + 1):
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

result = 0
# 각 학생을 번호에 따라 한 명씩 확인하며 도달 가능한지 체크
for a in range(1, n + 1):
    cnt = 0
    for b in range(1, n + 1):
       if graph[a][b] != inf or graph[b][a] != inf:
           cnt +=1
    if cnt == n:
        result += 1
        
print(result) 

'''
학생들의 성적 비교를 한 결과를 방향 그래프로 표현한 문제이다.
즉, 성적이 낮은 학생이 성적이 높은 학생을 가리키는 방향 그래프이다.
그러므로 최단 경로 알고리즘을 수행할 수 있게 된다.
A번 학생에서 B번 학생으로 가는 방향이 있거나 B번 학생에서 A번 학생으로 가는 방향이 있다면 둘의 대소관계를 알 수 있다.
하지만 반대로 두개 다 없다면, 대소 관계를 알 수 없다.
이 문제에서 학생 수 N이 500이하의 정수이므로 O(N3)의 시간 복작도인 프로이드 워셜 알고리즘을 이용해 문제를 해결 할 수 있다.

풀이 방법
1. 기존 플로이드 워셜 알고리즘 처럼, 자기 자신으로 가는 경로는 0으로 초기화
2. 간선 정보를 입력받아서 a 에서 b로 가는 방향 그래프 가 있다면 그 값을 1로 초기화 한다. 여기에선, 값이 중요한 게 아니라 값이 있다는 게 중요하기 때문에
3. 결과로 제출할 변수를 선언한다.(result)
4. 이중 반복문을 돌려서 첫번째 반복문 아래 count 변수를 선언한뒤, 바로 아래 반복문을 작성하고 a -> b 또는 b -> a로 가는 방향이 있는 지 확인하고, 있다면 count 를 더해준다.
5. 왜냐면 특정 A에 대한 다른 지점들과 비교가 모두 가능하다면 A에 대한 순위를 정확히 알 수 있기 때문이다. 그렇기에 count 가 전체 노드의 수 n 과 같다는 조건을 작성한다.
6. 위의 조건이 맞으면 result 에 1을 더해준다.
'''
