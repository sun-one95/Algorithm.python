'''
백준 12865 - 다이나믹 프로그래밍

이 문제는 정해진 가방 무게안에 물건을 넣는데, 물건마다 무게와 가치가 부여된다.
넣을 수 있는 물건 가치의 최댓값을 리턴해야 한다.

이 문제는 표를 그려서 하나하나씩 돌려보면 규칙을 찾을 수 있다.
(표와 비슷하게 아래 일일히 작업한 내용이 있다.)

각 물건의 무게(w1)와 가치(v1)를 순서대로 넣으면
일단 그 무게(w1)의 최대 가치는 방금 넣은 v1이다. 
그 이상의 무게도 지금은 v가 최댓값이다. (최대 무게 7까지만)

그 다음 무게(w2)와 가치(v2)를 가방에 넣으면
일단 이전에 넣었던 w1보다 낮다면 일단 w1 미만 무게들의 가치는 v2이다.
(w2 미만 무게에다가는 가치를 부여하지 않는다.)
그리고 w1무게 이상의 가치는 v1과 v2를 비교하여 결정한다.

마지막 규칙은 k번쨰 보석의 무게가 w, 가치가 v일때,
k-1번째의 결과중 무게가 w이상인 wi값에 대하여 wi-w의 v(i-w)+v와 현재가치 vi를 비교하여 큰 값을 할당한다.
이를 수식으로 표현하면 다음과 같다. 
dp[i] = max(dp[i], dp[i-w]+v) (단, i >= w)
'''


import sys

input = sys.stdin.readline

n, k = map(int, input().split())
arr = []
for i in range(n):
    w, v = map(int, input().split())
    arr.append((w, v))

dp = [0 for _ in range(k+1)]
for a in arr:
    w, v = a
    for i in range(k, w-1, -1):
        dp[i] = max(dp[i], dp[i-w] + v)

print(dp[-1])

'''
n, k = 4, 7
arr = [(6, 13), (4, 8), (3, 6), (5, 12)]

w, v = 6, 13 일때,
for i in range(7, 5, -1):
    i = 7일떄,
    dp[7] = max(dp[7], dp[7-6] + 13) = 13
    i = 6일떄,
    dp[6] = max(dp[6], dp[6-6] + 13) = 13

w, v = 4, 8일때,
for i in range(7, 3, -1):
    i = 7일떄,
    dp[7] = max(dp[7], dp[7-4] + 8) = 13
    i = 6일떄,
    dp[6] = max(dp[6], dp[6-4] + 8) = 13
    i = 5일때,
    dp[5] = max(dp[5], dp[5-4] + 8) = 8
    i = 4일떄,
    dp[4] = max(dp[4], dp[4-4] + 8) = 8

w, v = 3, 6일떄,
for i in range(7, 2, -1):
    i = 7일때,
    dp[7] = max(dp[7], dp[7-3] + 6) = 14
    i = 6일때,
    dp[6] = max(dp[6], dp[6-3] + 6) = 13
    i = 5일떄,
    dp[5] = max(dp[5], dp[5-3] + 6) = 8
    i = 4일때,
    dp[4] = max(dp[4], dp[4-3] + 6) = 8
    i = 3일때,
    dp[3] = max(dp[3], dp[3-3] + 6) = 6

w, v = 5, 12일떄,
for i in range(7, 4, -1):
    i = 7일떄,
    dp[7] = max(dp[7], dp[7-5] + 12) = 14
    i = 6일때,
    dp[6] = max(dp[6], dp[6-5] + 12) = 13
    i = 5일떄,
    dp[5] = max(dp[5], dp[5-5] + 12) = 12

dp = [0, 0, 0, 6, 8, 12, 13, 14]

'''