'''
백준 2156

연속으로 나열된 포도주들을 세번연속으로 마실 순 없다.
최대 두번 연속까지 가능하다.

1. 포도주의 개수가 최대 10000개 까지이다.
그래서 포도주의 양을 입력받아 저장해놓을 리스트를 만든다. (wines = [0] * 10000)
입력값으로 포도주의 양을 입력받는 데 이때 wines리스트에 저장한다. (wines[i] = int(input()))

2. 다이나믹 프로그래밍 로직을 짜는데,
초기값들을 먼저 정한다. 0에서 2까지는 손수 작성한다.
3이후부터는 모두 통하는 공통 로직을 짠다.

3. i번째에서 마실 수 있는 최대 포도주 양은 세가지 후보중에서 가장 큰값을 설정하면 된다.
하나는 i번째 포도주양(wines[i]) + i-1번째 포도주양(wines[i-1]) + i-3번째 포도주 최댓값(dp[i-3])
둘쨰는 i번째 포도주양(wines[i]) + i-1번째 포도주 최댓값(dp[i-1])
셋째는 i-1번째 까지 포도주 최댓값(dp[i-1]) * i번째 포도주를 마시는게 최댓값이 안나올 수 있으므로

이 셋중에 최댓값을 i번째까지 마실 수 있는 포도주의 최댓값으로 설정한다.

----------
어려웠던 점

일단 리스트를 만드는데 있어서 런타임 오류가 발생했다.
vs코드상에는 원하는 결과값이 출력됐는데 정작 백준채점에서는 런타임오류가 발생하였다.
그래서 이게 좀 이해가 안갔지만, n이 예시에서는 작은 값이었지만 커질 수록 오류가 발생하는 것 같아 
아예 초기리스트의 범위를 n의 최댓값으로 맞춰서 한것같다. n의 범위가 다행히 큰 값이 아니어서 시간초과도 잘 안걸리는 듯 했다.

'''

n = int(input())
wines = [0] * 10000
for i in range(n):
    wines[i] = int(input())

dp = [0] * 10000
dp[0] = wines[0]
dp[1] = wines[0] + wines[1]
dp[2] = max(wines[2] + wines[1], wines[2] + wines[0], dp[1])
for i in range(3, n):
    dp[i] = max(wines[i] + dp[i-2], wines[i] + wines[i-1] + dp[i-3], dp[i-1])

print(max(dp))