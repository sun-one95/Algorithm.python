# 내가 푼 풀이
# data = input()
# zero_cnt = 0
# one_cnt = 0
# for i in range(len(data)):
#     if data[i] == '0':
#         zero_cnt += 1
#     else:
#         one_cnt += 1

# if zero_cnt >= one_cnt:
#     print()

# else:
#     print(zero_cnt)

# 답안지
data = input()
count0 = 0 # 전부 0으로 바꾸는 경우
count1 = 0 # 전부 1로 바꾸는 경우

# 첫 번째 원소에 대해서 처리
if data[0] == '1':
    count0 += 1
else:
    count1 += 1

# 두 번째 원소부터 모든 원소를 확인하며
for i in range(len(data) - 1):
    if data[i] != data[i + 1]:
        # 다음 수에서 1로 바뀌는 경우
        if data[i + 1] == '1':
            count0 += 1
        # 다음 수에서 0으로 바뀌는 경우
        else:
            count1 += 1

print(min(count0, count1))

# 어려웠던 점: 처음에는 그냥 0과 1의 수를 다 구해서 가장 작은 수를 출력했는데, 그게 아니라 연속적인 경우 한번에 돌릴 수가 있다. 그래서 현재위치에 있는 수와 바로 다음 수를 비교해서 
# 풀었어야 했다. 
# 이 문제는 어려웠던게 일일히 숫자를 확인해서 0인 경우와 1인 경우를 찾은 다음에 어떻게 해야 뒤집고 그 최소경우의 수를 구할 수 있는지 좋은 방법이 잘 떠오르지 못했다.
# 위 방법은 변수를 두개 준비해서 하나는 0으로 바꿨을 때의 횟수이고, 두번째는 1로 바꿨을 때의 경우의 수이다. 하나씩 일일히 확인해서 마지막에 이 두변수 중에 가장 최속값을
# 리턴하면 된다.
# 첫 원소에 대해서 0인지 1인지 확인하여 0인 경우에는 1로 바꿔주고(변수0에 +1) 0인 경우(변수1에 +1) 처리해 준다.
# 그런다음 이제 반복문을 돌려서 i번째와 i+1번째 수가 같은 지 확인하고, 다른 경우에 아까 첫번째 원소를 처리했던 것처럼 처리해 준다.
# 실제로 코드 상에서는 1을 0으로 0을 1로 바꾸지 않고 변수들을 선언해서 바꿨다고 가정하에 +1을 해주는 방법이 인상깊었다. 이러한 방법을 유념하여 문제를 풀어가야 겠다.

