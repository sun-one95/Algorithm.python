n = int(input())
arr = list(map(int, input().split()))

arr.sort()
# 부분집합처럼 arr가 만 들 수 있는  정수들로 만들 수 있는 함 수들을 리스트에 담을 까?
# 가장 작안 양의 정수니 까 작은 정 수
# 처음에는 금액 1을 만들 수 있는지 확인하기 위해, target = 1로 설정한다.
# target = 1을 만족할 수 있는지 확인한다. 우리에게는 화폐 단위가 1인 동전이 있다. 우리는 이 동전을 이용해서 
# 금액 1을 만들 수 있다. 이어서 target = 1 + 1 = 2로 업데이트를 한다. (1까지의 모든 금액을 만들 수 있다는 말과 같다)
# target = 2를 만족 할 수 있는지 왁인한다. 우리에게는 화폐 단위가 2인 동전이 있다. 따라서 target = 2 + 2 = 4가 된다.(3까지의 모든 금액을 만들 수 있다는 말과 같다)
# target = 4를 만족할 수 있는지 확인한다. 우리에게는 화폐 단위가 3인 동전이 있다. 따라서 target = 4 + 3 = 7이 된다.(6까지의 모든 금액을 만들 수 있다는 말과 같다.)
# target = 7을 만족할 수 있는지 확인한다. 우리에게는 이보다 큰, 화폐 단위가 8인 동전이 있다. 따라서 금액 7을 만드는 방법은 없다. 따라서 정답은 7이 된다

target = 1
for x in arr:
    # 만들 수 없는 금액을 찾았을 때 반복 종료
    if target < x:
        break
    target += x

# 만들 수 없는 금액 출력
print(target)

# 오늘의 어려운 점: 그리디라는 유형의 문제를 많이 풀어보지 않아서 접근 방법이 어려웠다.
# 1. 먼저 동전에 대한 정보가 주어졌을 때, 화폐단위를 기준으로 오름차순 정렬을 한다.
# 2. 문제 자체가 만들 수 없는 금액을 리턴하는 문제다. 그러니까, 특정 i 금액을 만들 수 있다면 그 전 1 부터 i - 1 까지의 금액을 만든다는 말이다.
# 3. 그러므로 이 문제를 풀려면, target 이리는 변수를 선언해서, 1부터 시작하여 확인을 한다.
# 4. 만약 target 보다 i 금액이 크다면, 즉 만들 수 없는 금액을 찾았다면 반복문을 종료한다.
# 5. 위의 조건에 부합하지 않는다면, 즉, 만들 수 있는 금액이라면, 이제 다음 금액을 만들 수 있는지 확인해야 하므로 target 에 비교한 i금액을 더해준 값을 할당한다.
# 6. 마지막으로 target 을 리턴한다.
# 처음에는 이러한 풀이를 이해하지 못했다. 왜 1~2의 말이 이해가 가지 않았다. target으로 하는 숫자를 만들 수 있다면, 그 전 금액을 만들 수 있다는 해석은 정말 잊지 못할 것 같다.
# 이러한 접근법이 내가 주로 쓰는 풀이가 아니라서 낯설었지만, 좋은 풀이 방법이었다.